# 布隆过滤器Bloom Filter

## 是什么

1.由一个初值都为零的bit数组和多个哈希函数构成，用来快速判断某个数据是否存在

2.本质就是判断具体数据存不存在一个大集合中

3.布隆过滤器是一种类似set的数据结构，只是统计**结果不太准确**

## 特点

1.高效的插入和查询，占用空间小，返回的结果是不确定性的

2.**一个元素如果判断结果为存在的时候元素不一定存在，但是判断结果为不存在的时候则一定不存在**

3.布隆过滤器可以添加元素，但是不能删除元素，因为删除元素会导致误判率增加

4.误判只会发生在过滤器没有添加过的元素，对于添加过的元素不会发生误判

## 使用场景

1.解决**缓存穿透**的问题

tip：缓存穿透问题：redis没有缓存，请求直接去到数据库，在极大的并发下干崩数据库



2.黑名单校验



## 原理

**一个bit数组+多个哈希函数**

bloom过滤器，将key通过多个哈希函数计算出哈希值，然后再取模放到一个bit数组里对应的槽，将0置1，多个哈希函数对应多个槽。

### 添加

当我们向布降过滤器中添加数据时，为了尽量地址不冲突，会使用**多个hash 函数对 key 进行运算**，算得一个下标索引值，然后对位数组长度进行取模运算得到一个位置，每个 hash 函数都会算得一个不同的位置。再把位数组的这几个位置都置为 1 就完成了 add 操作。

### 判断key是否存在

向布隆过滤器查询某个key是否存在时，先把这个 key 通过相同的多个 hash 函数进行运算，查看对应的位置是否都为1.

**只要有一个位为 0，那么说明布隆过滤器中这个 key 不存在;**

**如果这几个位置全都是 1，那么说明极有可能存在;**

因为这些位置的 1 可能是因为其他的 key 存在导致的，也就是前面说过的hash冲突。



### 小问题

为什么布隆过滤器不要删除？

**会增加误判率**

布隆过滤器的误判是指多个输入经过哈希之后在相同的bit位置1了，这样就无法判断究竟是哪个输入产生的,因此误判的根源在于相同的 bit 位被多次映射且置 1。
这种情况也造成了布隆过滤器的删除问题，**因为布隆过滤器的每一个 bit 并不是独占**的，很有可能多个元素共享了某一位。如果我们直接删除这一位的话，会影响其他的元素



## 布隆过滤器的缺点

1.不能删除元素，删除导致误判率增加

2.存在误判，无法避免哈希冲突
