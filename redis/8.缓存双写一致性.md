# 缓存双写一致性

## canal

**是什么？**

Canal是基于MySQL变更日志增量订阅和消费的组件



**能干嘛？**

* 数据库镜像数据库实时备份

* 带业务逻辑的增量数据处理

* 索引构建和实时维护(拆分异构索引、倒排索引等)

* 业务 cache 刷新
  
  
  

**传统mysql主从复制工作原理**

![](C:\Users\sugon\Desktop\study_note\images\2023-02-13-09-05-51-image.png)

MySQL的主从复制将经过如下步骤：
1、当 master 主服务器上的数据发生改变时，则将其改变写入**二进制事件日志**文件中;

2、salve 从服务器会在一定时间间隔内对 master 主服务器上的二进制日志进行探测，探测其是否发生过改变如果探测到 master 主服务器的二进制事件日志发生了改变，则开始一个I/0 Thread 请求 master 二进制事件日志;

3、同时 master 主服务器为每个I/0 Thread 启动一个dump Thread，用于向其发送二进制事件日志;

4、slave 从服务器将接收到的二进制事件日志保存至自己本地的**中继日志文件**中;
5、salve 从服务器将启动 SQL Thread 从中继日志中读取二进制日志，在本地重放，使得其数据和主服务器保持一致;

6、最后 I/O Thread 和 SQL Thread 将进入睡眠状态，等待下一次被唤醒;



**canal 工作原理**

canal 模拟 MySQL slave 的交协议，伪装自己为 MySQL slave，向 MySQL master 发送dump 协议MySQL master 收到 dump 请求，开始推送 binary log 给 slave (即 canal)canal 解析 binary log 对象(原始为 byte 流)

![](C:\Users\sugon\Desktop\study_note\images\2023-02-13-09-14-18-image.png)

结论之一：

**分布式系统只有最终一致性，很难做到强一致性**





## 缓存双写一致性

如果redis中有数据，需要和数据库中的值相同
如果redis中无数据，数据库中的值要是最新值


给缓存设置过期时间，是保证最终一致性的解决方案。
我们可以对存入缓存的数据设置过期时间，**所有的写操作以数据库为准**，对缓存操作只是尽最大努力即可。也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存，达到一致性，**切记以mysql的数据库写入库为准。**

## 三种更新策略

1. **先更新数据库，再更新缓存**

2. **先删除缓存，再更新数据库**

3. **先更新数据库，再删除缓存**



不允许先更新缓存再更新数据库，一定要以写入数据库为准



**第一种策略**

**异常问题：**

1.先更新mysql的某商品的库存，当前商品的库存是100，更新为99个。
2.先更新mysql修改为99成功，然后更新redis。
3.此时假设异常出现，更新redis失败了，这导致mysq里面的库存是99而redis里面的还是100
4.上述发生，会让数据库里面和缓存redis里面数据不一致，读到脏数据



**第二种策略：**

**异常问题：**

在低并发下，很可能读回旧值；在高并发下，很可能缓存击穿

![](C:\Users\sugon\Desktop\study_note\images\2023-02-13-10-15-57-image.png)

![](C:\Users\sugon\Desktop\study_note\images\2023-02-13-10-17-42-image.png)



**解决方案：**

采用延时双删策略

加上sleep的这段时间，就是为了让线程B能够先从数据库读取数据，再把缺失的数据写入缓存然后，线程A再进行删除。所以，线程A sleep的时间，就需要大于线程B读取数据再写入缓存的时间。这样一来，其它线程读取数据时，会发现缓存缺失，所以会从数据库中读取最新值。因为这个方案会在第一次删除缓存值后，延迟一段时间再次进行删除，所以我们也把它叫做“延迟双删”。



但是延时双删也有自己的问题，就是这个延时怎么定的问题



**第三种策略**

异常问题：

假如缓存删除失败或者来不及，导致请求再次访问redis时缓存命中，**读取到的是缓存旧值**。



解决方案

重试机制+引入MQ

![](C:\Users\sugon\Desktop\study_note\images\2023-02-13-10-39-52-image.png)

流程如下图所示:
(1) 更新数据库数据
(2) 数据会将操作信息写入binlog日志当中

(3)订阅程序提取出所需要的数据以及key

(4)另起一段非业务代码，获得该信息

(5) 尝试删除缓存操作，发现删除失败

(6) 将这些信息发送至消息队列

(7)重新从消息队列中获得该数据，重试操作



## 总结

个人建议是，**优先使用先更新数据库，再删除缓存**的方案。理由如下:
1.先删除缓存值再更新数据库，有可能导致请求因缓存缺失而访问数据库，给数据库带来压力，严重导致打满mysql.
2.如果业务应用中读取数据库和写缓存的时间不好估算，那么，延迟双删中的等待时间就不好设置。



多补充一句:如果使用先更新数据库，再删除缓存的方案
如果**业务层要求必须读取一致性的数据**，那么我们就需要在更新数据库时，**先在Redis缓存客户端暂存并发读请求**，等数据库更新完、缓存值删除后，再读取数据，从而保证数据一致性。



![](C:\Users\sugon\Desktop\study_note\images\2023-02-13-10-50-04-image.png)


